// just a helper script to generate exports for all atproto lexica

import * as fs from "jsr:@std/fs@1";
import * as path from "jsr:@std/path@1";

if (!(await fs.exists("../atproto"))) {
  throw new Error("atproto directory was not cloned as a sibling of lexicon.ts! can't generate :(");
}

const atprotoDir = path.resolve("../atproto");
const names = new Map<string, string>();

for await (const entry of fs.expandGlob("../atproto/lexicons/**/*.json")) {
  if (!entry.isFile) continue;

  const lexiconPath = entry.path.substring(`${atprotoDir}/lexicons/`.length);
  const lexiconJson = JSON.parse(await Deno.readTextFile(entry.path));
  const lexiconName = (lexiconJson["id"] as string).replaceAll(/[.-]/g, "_");

  const modulePath = lexiconPath.replace(/\.json$/, ".ts");
  const outputPath = "./atproto-lex/" + modulePath;
  await fs.ensureDir(path.dirname(outputPath));
  await Deno.writeTextFile(outputPath, `// generated by lexicon.ts/lex-gen  
import { Unconstify } from "@char/lexicon.ts";

export const _Lexicon_${lexiconName} = ${JSON.stringify(lexiconJson, undefined, 2)} as const;
export type _LexiconT_${lexiconName} = Unconstify<typeof _Lexicon_${lexiconName}>;
`
  );
  names.set(lexiconName, modulePath);

  console.log("[+]", outputPath);
}

await Deno.writeTextFile("./atproto-lex/mod.ts", `// generated by lexicon.ts/lex-gen
import { LexiconUniverse } from "@char/lexicon.ts";

${[...names.entries()].map(([k, v]) =>
  `import type { _LexiconT_${k} } from ${JSON.stringify("./" + v)}`)
  .join("\n")}

export type ATProtoUniverse = LexiconUniverse<[${[...names.keys()]
  .map(s => `_LexiconT_${s}`)
  .join(", ")}]>
`)
