// just a helper script to generate exports for all atproto lexica

import * as fs from "jsr:@std/fs@1";
import { dirname, resolve as resolvePath } from "jsr:@std/path@1";
const json = JSON.stringify;

const UNIVERSE_NAME = "ATProtoUniverse";

if (!(await fs.exists("../atproto"))) {
  throw new Error("atproto directory was not cloned as a sibling of lexicon.ts! can't generate :(");
}

const atprotoDir = resolvePath("../atproto");
const modules = new Set<{ name: string; path: string; id: string; }>();

for await (const entry of fs.expandGlob("../atproto/lexicons/**/*.json")) {
  if (!entry.isFile) continue;

  const lexiconPath = entry.path.substring(`${atprotoDir}/lexicons/`.length);
  const lexiconJson = JSON.parse(await Deno.readTextFile(entry.path));

  const id = lexiconJson["id"] as string;
  const name = id.replaceAll(/[\.-]/g, "_");
  const path = lexiconPath.replace(/\.json$/, ".ts");

  const outputPath = "./atproto-lex/" + path;
  await fs.ensureDir(dirname(outputPath));
  await Deno.writeTextFile(outputPath, `// generated by lexicon.ts/lex-gen  
import { Unconstify } from "@char/lexicon.ts";

export const _Lexicon_${name} = ${JSON.stringify(lexiconJson, undefined, 2)} as const;
export type _LexiconT_${name} = Unconstify<typeof _Lexicon_${name}>;
`
  );
  modules.add({ name, path, id });

  console.log("[+]", outputPath);
}

await Deno.writeTextFile("./atproto-lex/mod.ts", `// generated by lexicon.ts/lex-gen
import { LexiconUniverse } from "@char/lexicon.ts";

${[...modules].map(mod =>
  `import type { _LexiconT_${mod.name} } from ${json("./" + mod.path)}`)
  .join("\n")}

export type ${UNIVERSE_NAME} = LexiconUniverse<[${[...modules]
  .map(mod => `_LexiconT_${mod.name}`)
  .join(", ")}]>;
`);

const validatorTemplate = await Deno.readTextFile("./lex-gen/validator.ts.tmpl");
await Deno.writeTextFile("./atproto-lex/validate.ts", [
  `import type { ${UNIVERSE_NAME} } from "./mod.ts"`,
  validatorTemplate.replaceAll("$__UNIVERSE__", UNIVERSE_NAME)
].join("\n"));
